{% extends "dashboard/base.html" %}

{% block title %}AMOSKYS Cortex Command Center{% endblock %}

{% block content %}
<div class="command-center-v2">
    <!-- Welcome Header -->
    <div class="neural-card">
        <div class="card-header">
            <h2 class="card-title">üß† AMOSKYS Cortex Command Center</h2>
            <div class="card-badge badge-success">Phase 2.4 Active</div>
        </div>
        <p style="color: var(--text-secondary); margin-bottom: 1rem;">
            Real-time neural security monitoring and threat analysis for distributed infrastructure.
        </p>
        <div style="display: flex; gap: 1rem; flex-wrap: wrap;">
            <a href="/dashboard/soc" class="neural-button">üõ°Ô∏è SOC Operations</a>
            <a href="/dashboard/agents" class="neural-button">ü§ñ Manage Agents</a>
            <a href="/dashboard/processes" class="neural-button">üî¨ Process Telemetry</a>
            <a href="/dashboard/neural" class="neural-button">üß† Neural Insights</a>
        </div>
    </div>

    <!-- Real-time Metrics Grid -->
    <div class="metrics-grid-v2">
        <div class="metric-card">
            <div class="metric-value" id="threat-score">0</div>
            <div class="metric-label">Threat Level</div>
            <div class="metric-detail" id="threat-status">NORMAL</div>
        </div>
        
        <div class="metric-card">
            <div class="metric-value" id="agent-count">0</div>
            <div class="metric-label">Active Agents</div>
            <div class="metric-detail" id="agent-status">Initializing...</div>
        </div>
        
        <div class="metric-card">
            <div class="metric-value" id="event-count">0</div>
            <div class="metric-label">Events (24h)</div>
            <div class="metric-detail" id="event-status">Monitoring...</div>
        </div>
        
        <div class="metric-card">
            <div class="metric-value" id="health-score">0%</div>
            <div class="metric-label">System Health</div>
            <div class="metric-detail" id="health-status">Checking...</div>
        </div>
    </div>

    <!-- System Metrics Dashboard -->
    <div class="neural-card">
        <div class="card-header">
            <h3 class="card-title">üìä System Performance</h3>
            <span class="metric-timestamp" id="metrics-timestamp">Last updated: -</span>
        </div>
        <div class="system-metrics-grid">
            <div class="metric-box">
                <div style="position: relative; width: 120px; height: 120px; margin: 0 auto;">
                    <canvas id="cpu-chart"></canvas>
                </div>
                <div class="metric-box-label">CPU Usage</div>
                <div class="metric-box-value" id="cpu-value">--%</div>
            </div>
            <div class="metric-box">
                <div style="position: relative; width: 120px; height: 120px; margin: 0 auto;">
                    <canvas id="memory-chart"></canvas>
                </div>
                <div class="metric-box-label">Memory Usage</div>
                <div class="metric-box-value" id="memory-value">--%</div>
            </div>
            <div class="metric-box">
                <div style="position: relative; width: 120px; height: 120px; margin: 0 auto;">
                    <canvas id="disk-chart"></canvas>
                </div>
                <div class="metric-box-label">Disk Usage</div>
                <div class="metric-box-value" id="disk-value">--%</div>
            </div>
            <div class="metric-box">
                <div style="position: relative; width: 120px; height: 120px; margin: 0 auto;">
                    <canvas id="network-chart"></canvas>
                </div>
                <div class="metric-box-label">Network Activity</div>
                <div class="metric-box-value" id="network-value">--%</div>
            </div>
        </div>
    </div>

    <!-- Recent Events and Status -->
    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 1.5rem; margin-top: 2rem;">
        <!-- Recent Threats -->
        <div class="neural-card">
            <div class="card-header">
                <h3 class="card-title">‚ö†Ô∏è Recent Threats</h3>
            </div>
            <div id="threats-container" style="max-height: 300px; overflow-y: auto;">
                <div style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                    Loading threats...
                </div>
            </div>
        </div>

        <!-- Agent Status -->
        <div class="neural-card">
            <div class="card-header">
                <h3 class="card-title">ü§ñ Agent Network</h3>
            </div>
            <div id="agents-container" style="max-height: 300px; overflow-y: auto;">
                <div style="color: var(--text-secondary); text-align: center; padding: 2rem;">
                    Loading agents...
                </div>
            </div>
        </div>
    </div>
</div>

<style>
.command-center-v2 {
    padding: 2rem;
}

.metrics-grid-v2 {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1.5rem;
    margin: 2rem 0;
}

.metric-card {
    background: linear-gradient(135deg, rgba(0, 255, 136, 0.1), rgba(0, 136, 255, 0.1));
    border: 2px solid rgba(0, 255, 136, 0.3);
    border-radius: 12px;
    padding: 1.5rem;
    text-align: center;
}

.metric-value {
    font-size: 2.5rem;
    font-weight: 700;
    color: #00ff88;
    text-shadow: 0 0 10px #00ff88;
    margin-bottom: 0.5rem;
}

.metric-label {
    color: var(--text-secondary);
    font-size: 0.9rem;
    text-transform: uppercase;
    letter-spacing: 1px;
}

.metric-detail {
    color: #0088ff;
    font-size: 0.8rem;
    margin-top: 0.5rem;
}

.metric-timestamp {
    font-size: 0.75rem;
    color: var(--text-muted);
}

.system-metrics-grid {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    gap: 2rem;
    padding: 1.5rem 0;
}

.metric-box {
    text-align: center;
}

.metric-box canvas {
    margin: 0 auto;
    display: block;
}

.metric-box-label {
    color: var(--text-secondary);
    margin-top: 1rem;
    font-size: 0.9rem;
}

.metric-box-value {
    color: #00ff88;
    font-weight: 700;
    font-size: 1.2rem;
    margin-top: 0.3rem;
}

#threats-container > div,
#agents-container > div {
    padding: 0.8rem;
    border-bottom: 1px solid rgba(0, 255, 136, 0.1);
    font-size: 0.9rem;
    line-height: 1.4;
}

#threats-container > div:last-child,
#agents-container > div:last-child {
    border-bottom: none;
}

.threat-item {
    padding: 1rem !important;
    background: rgba(255, 51, 102, 0.1);
    border-left: 3px solid #ff3366;
    margin-bottom: 0.5rem;
    border-radius: 4px;
}

.threat-type {
    color: #ff3366;
    font-weight: 700;
}

.threat-time {
    color: var(--text-muted);
    font-size: 0.8rem;
    margin-top: 0.3rem;
}

.agent-item {
    padding: 1rem !important;
    background: rgba(0, 136, 255, 0.1);
    border-left: 3px solid #0088ff;
    margin-bottom: 0.5rem;
    border-radius: 4px;
}

.agent-name {
    color: #00ff88;
    font-weight: 700;
}

.agent-status {
    color: #00ff88;
    font-size: 0.85rem;
    margin-top: 0.3rem;
}

.status-online {
    color: #00ff88;
}

.status-offline {
    color: #ffaa00;
}

.status-error {
    color: #ff3366;
}
</style>

<script>
class CortexDashboardV2 {
    constructor() {
        this.charts = {};
        this.updateInterval = 5000; // 5 seconds
        this.updateTimer = null;
        this.failureCount = { metrics: 0, threats: 0, agents: 0, health: 0 };
        this.maxRetries = 3;
        this.lastUpdateTime = { metrics: null, threats: null, agents: null, health: null };
        this.init();
    }

    async init() {
        console.log('Initializing Cortex Dashboard V2');
        this.initCharts();
        this.startUpdates();
        // Do initial update immediately
        await this.updateAll();
    }

    initCharts() {
        const chartConfig = {
            type: 'doughnut',
            options: {
                responsive: true,
                maintainAspectRatio: true,
                cutout: '70%',
                plugins: {
                    legend: { display: false },
                    tooltip: { enabled: false }
                }
            }
        };

        // CPU Chart
        this.charts.cpu = new Chart(document.getElementById('cpu-chart'), {
            ...chartConfig,
            data: {
                datasets: [{
                    data: [0, 100],
                    backgroundColor: ['#00ff88', 'rgba(255, 255, 255, 0.1)'],
                    borderWidth: 0
                }]
            }
        });

        // Memory Chart
        this.charts.memory = new Chart(document.getElementById('memory-chart'), {
            ...chartConfig,
            data: {
                datasets: [{
                    data: [0, 100],
                    backgroundColor: ['#0088ff', 'rgba(255, 255, 255, 0.1)'],
                    borderWidth: 0
                }]
            }
        });

        // Disk Chart
        this.charts.disk = new Chart(document.getElementById('disk-chart'), {
            ...chartConfig,
            data: {
                datasets: [{
                    data: [0, 100],
                    backgroundColor: ['#ffaa00', 'rgba(255, 255, 255, 0.1)'],
                    borderWidth: 0
                }]
            }
        });

        // Network Chart (synthetic - bytes sent/recv ratio)
        this.charts.network = new Chart(document.getElementById('network-chart'), {
            ...chartConfig,
            data: {
                datasets: [{
                    data: [50, 50],
                    backgroundColor: ['#ff00ff', 'rgba(255, 255, 255, 0.1)'],
                    borderWidth: 0
                }]
            }
        });

        console.log('Charts initialized');
    }

    startUpdates() {
        // Update every 5 seconds
        this.updateTimer = setInterval(() => this.updateAll(), this.updateInterval);
        // Cleanup on page unload
        window.addEventListener('beforeunload', () => this.cleanup());
    }

    cleanup() {
        if (this.updateTimer) {
            clearInterval(this.updateTimer);
            this.updateTimer = null;
        }
    }

    /**
     * Display error state in UI with retry button
     */
    showErrorState(containerId, message, retryFn) {
        const container = document.getElementById(containerId);
        if (!container) return;
        
        const errorHtml = `
            <div style="color: #ff3366; padding: 1rem; border: 1px solid #ff3366; border-radius: 4px; background: rgba(255, 51, 102, 0.1);">
                <div style="font-weight: 700; margin-bottom: 0.5rem;">‚ö†Ô∏è Error</div>
                <div style="font-size: 0.9rem; margin-bottom: 1rem;">${message}</div>
                <button onclick="window.cortexDashboard && window.cortexDashboard.retryUpdate('${containerId}')" 
                    style="padding: 0.5rem 1rem; background: #ff3366; color: white; border: none; border-radius: 4px; cursor: pointer;">
                    Retry
                </button>
            </div>
        `;
        container.innerHTML = errorHtml;
    }

    /**
     * Get time elapsed since last successful update
     */
    getTimeSinceUpdate(updateType) {
        const lastTime = this.lastUpdateTime[updateType];
        if (!lastTime) return 'Never';
        
        const elapsed = Math.floor((Date.now() - lastTime) / 1000);
        if (elapsed < 60) return elapsed + 's ago';
        if (elapsed < 3600) return Math.floor(elapsed / 60) + 'm ago';
        return Math.floor(elapsed / 3600) + 'h ago';
    }

    /**
     * Update timestamp display with freshness indicator
     */
    updateTimestampDisplay(elementId, updateType) {
        const element = document.getElementById(elementId);
        if (!element) return;
        
        const elapsed = this.getTimeSinceUpdate(updateType);
        const color = this.getTimestampColor(this.lastUpdateTime[updateType]);
        element.textContent = `Last updated: ${elapsed}`;
        element.style.color = color;
    }

    /**
     * Determine color based on data freshness
     */
    getTimestampColor(lastTime) {
        if (!lastTime) return '#ff3366'; // Error red
        const elapsed = Date.now() - lastTime;
        if (elapsed < 10000) return '#00ff88'; // Fresh - green
        if (elapsed < 30000) return '#ffaa00'; // Stale - yellow
        return '#ff3366'; // Very stale - red
    }

    /**
     * Retry a specific update
     */
    async retryUpdate(updateType) {
        console.log('Retrying update:', updateType);
        if (updateType === 'metrics') await this.updateMetrics();
        else if (updateType === 'threats') await this.updateThreats();
        else if (updateType === 'agents') await this.updateAgents();
    }

    cleanup() {
        if (this.updateTimer) {
            clearInterval(this.updateTimer);
            this.updateTimer = null;
        }
    }

    async updateAll() {
        try {
            await Promise.all([
                this.updateHealthStatus(),
                this.updateMetrics(),
                this.updateThreats(),
                this.updateAgents()
            ]);
        } catch (error) {
            console.error('Update error:', error);
        }
    }

    /**
     * Fetch from Health API v1 for Command Center metrics
     * This provides real threat level, health score, and agent coverage
     */
    async updateHealthStatus() {
        try {
            const response = await fetch('/api/v1/health/system', { timeout: 5000 });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.json();
            if (data.status !== 'success') throw new Error('API error: ' + data.status);

            // Update Threat Level card
            const threatLevel = data.threat_level || 'BENIGN';
            document.getElementById('threat-score').textContent = 
                threatLevel === 'BENIGN' ? '0' :
                threatLevel === 'LOW' ? '1' :
                threatLevel === 'MEDIUM' ? '2' :
                threatLevel === 'HIGH' ? '3' :
                threatLevel === 'CRITICAL' ? '4' : '5';
            document.getElementById('threat-status').textContent = threatLevel;
            document.getElementById('threat-status').style.color = this.getThreatColor(threatLevel);

            // Update Health Score card (from Health API)
            const healthScore = data.health_score || 0;
            document.getElementById('health-score').textContent = healthScore + '%';
            document.getElementById('health-status').textContent = data.health_status?.toUpperCase() || 'UNKNOWN';
            document.getElementById('health-status').style.color = 
                healthScore >= 70 ? '#00ff88' : healthScore >= 40 ? '#ffaa00' : '#ff3366';

            // Update Events (24h) card
            const events24h = data.events_last_24h || 0;
            document.getElementById('event-count').textContent = events24h;
            document.getElementById('event-status').textContent = events24h > 0 ? 'ACTIVE' : 'MONITORING';

            // Update Agent count from health API
            const agentsSummary = data.agents_summary || {};
            const online = agentsSummary.online || 0;
            const total = agentsSummary.total || 0;
            document.getElementById('agent-count').textContent = `${online}/${total}`;
            document.getElementById('agent-status').textContent = 
                online === total && total > 0 ? 'ALL ONLINE' : 
                online > 0 ? 'PARTIAL' : 'OFFLINE';

            // Handle empty state
            if (data.empty_state) {
                this.showEmptyState(data.empty_state_message);
            }

            // Update timestamp
            this.lastUpdateTime.health = Date.now();
            this.failureCount.health = 0;

        } catch (error) {
            console.error('Health status update failed:', error);
            this.failureCount.health++;
            
            // Fall back to old method if health API fails
            if (this.failureCount.health >= this.maxRetries) {
                console.warn('Health API unavailable, using fallback metrics');
            }
        }
    }

    getThreatColor(level) {
        const colors = {
            'BENIGN': '#00ff88',
            'LOW': '#00ff88',
            'MEDIUM': '#ffaa00',
            'HIGH': '#ff6600',
            'CRITICAL': '#ff3366',
            'UNDER_ATTACK': '#ff0000'
        };
        return colors[level] || '#ffffff';
    }

    showEmptyState(message) {
        // Update containers with empty state message
        const threatsContainer = document.getElementById('threats-container');
        const agentsContainer = document.getElementById('agents-container');
        
        const emptyHtml = `
            <div style="color: var(--text-secondary); text-align: center; padding: 2rem; border: 1px dashed rgba(0, 255, 136, 0.3); border-radius: 8px; margin: 1rem 0;">
                <div style="font-size: 2rem; margin-bottom: 0.5rem;">üöÄ</div>
                <div style="font-weight: 700; margin-bottom: 0.5rem;">Fresh Install</div>
                <div style="font-size: 0.9rem;">${message || 'Deploy agents to start monitoring.'}</div>
            </div>
        `;
        
        if (threatsContainer && !this.hasRealData) {
            threatsContainer.innerHTML = emptyHtml.replace('Deploy agents', 'No threats detected yet');
        }
    }

    async updateMetrics() {
        try {
            const response = await fetch('/dashboard/api/live/metrics', { timeout: 5000 });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.json();
            if (data.status !== 'success') throw new Error('API error: ' + data.status);

            const metrics = data.metrics;
            
            // Update CPU
            const cpu = Math.round(metrics.cpu.percent);
            document.getElementById('cpu-value').textContent = cpu + '%';
            this.updateChart('cpu', cpu);

            // Update Memory
            const mem = Math.round(metrics.memory.percent);
            document.getElementById('memory-value').textContent = mem + '%';
            this.updateChart('memory', mem);

            // Update Disk
            const disk = Math.round(metrics.disk.percent);
            document.getElementById('disk-value').textContent = disk + '%';
            this.updateChart('disk', disk);

            // Calculate network activity (synthetic)
            const netTotal = metrics.network.bytes_sent + metrics.network.bytes_recv;
            const netPercent = Math.min(100, Math.round((netTotal / (1024 * 1024 * 1024)) % 100));
            document.getElementById('network-value').textContent = netPercent + '%';
            this.updateChart('network', netPercent);

            // Update health score
            const health = Math.round((100 - cpu + 100 - mem + 100 - disk) / 3);
            document.getElementById('health-score').textContent = health + '%';
            document.getElementById('health-status').textContent = 
                health > 80 ? 'OPTIMAL' : health > 60 ? 'GOOD' : 'WARNING';

            // Update timestamp with freshness indicator
            this.lastUpdateTime.metrics = Date.now();
            this.updateTimestampDisplay('metrics-timestamp', 'metrics');
            
            // Clear any previous error state
            this.failureCount.metrics = 0;

        } catch (error) {
            console.error('Metrics update failed:', error);
            this.failureCount.metrics++;
            
            if (this.failureCount.metrics >= this.maxRetries) {
                this.showErrorState('metrics-error', 
                    `Failed to fetch metrics: ${error.message}. Retrying...`,
                    () => this.updateMetrics());
                document.getElementById('health-status').textContent = 'Connection Error';
            }
        }
    }

    async updateThreats() {
        try {
            const response = await fetch('/dashboard/api/live/threats', { timeout: 5000 });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.json();
            if (data.status !== 'success') throw new Error('API error');

            const container = document.getElementById('threats-container');
            
            if (data.threats.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 2rem;">No threats detected in last 24 hours</div>';
            } else {
                container.innerHTML = data.threats.slice(0, 10).map(threat => `
                    <div class="threat-item">
                        <div class="threat-type">${threat.type.toUpperCase()}</div>
                        <div style="color: var(--text-secondary); font-size: 0.85rem;">
                            ${threat.description || threat.source_ip || 'No details'}
                        </div>
                        <div class="threat-time">${new Date(threat.timestamp).toLocaleString()}</div>
                    </div>
                `).join('');
            }

            document.getElementById('event-count').textContent = data.count;
            document.getElementById('event-status').textContent = data.count > 0 ? 'ACTIVE' : 'NORMAL';

            // Update timestamp with freshness indicator
            this.lastUpdateTime.threats = Date.now();
            
            // Clear any previous error state
            this.failureCount.threats = 0;

        } catch (error) {
            console.error('Threats update failed:', error);
            this.failureCount.threats++;
            
            if (this.failureCount.threats >= this.maxRetries) {
                this.showErrorState('threats-container', 
                    `Failed to fetch threats: ${error.message}. Click Retry to try again.`);
                document.getElementById('event-status').textContent = 'Error';
            }
        }
    }

    async updateAgents() {
        try {
            const response = await fetch('/dashboard/api/live/agents', { timeout: 5000 });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const data = await response.json();
            if (data.status !== 'success') throw new Error('API error');

            const container = document.getElementById('agents-container');
            
            if (!data.agents || data.agents.length === 0) {
                container.innerHTML = '<div style="color: var(--text-secondary); text-align: center; padding: 2rem;">No agents registered</div>';
                document.getElementById('agent-count').textContent = '0';
                document.getElementById('agent-status').textContent = 'No Agents';
            } else {
                const onlineCount = data.agents.filter(a => a.status === 'online').length;
                document.getElementById('agent-count').textContent = onlineCount + '/' + data.agents.length;
                document.getElementById('agent-status').textContent = 
                    onlineCount === data.agents.length ? 'ALL ONLINE' : 
                    onlineCount > 0 ? 'PARTIAL' : 'OFFLINE';

                container.innerHTML = data.agents.slice(0, 5).map(agent => {
                    const statusClass = agent.status === 'online' ? 'status-online' : 'status-offline';
                    return `
                        <div class="agent-item">
                            <div class="agent-name">${agent.agent_id || agent.id}</div>
                            <div class="agent-status ${statusClass}">
                                ‚óè ${agent.status || 'unknown'}
                            </div>
                            ${agent.last_heartbeat ? `<div class="threat-time">Last seen: ${new Date(agent.last_heartbeat).toLocaleString()}</div>` : ''}
                        </div>
                    `;
                }).join('');
            }

            // Update timestamp with freshness indicator
            this.lastUpdateTime.agents = Date.now();
            
            // Clear any previous error state
            this.failureCount.agents = 0;

        } catch (error) {
            console.error('Agents update failed:', error);
            this.failureCount.agents++;
            
            if (this.failureCount.agents >= this.maxRetries) {
                this.showErrorState('agents-container', 
                    `Failed to fetch agents: ${error.message}. Click Retry to try again.`);
                document.getElementById('agent-status').textContent = 'Error';
            }
        }
    }

    updateChart(chartName, percentage) {
        const chart = this.charts[chartName];
        if (chart && chart.data.datasets[0]) {
            chart.data.datasets[0].data = [percentage, 100 - percentage];
            chart.update('none'); // 'none' = no animation (faster)
        }
    }
}

// Initialize on page load
document.addEventListener('DOMContentLoaded', () => {
    window.cortexDashboard = new CortexDashboardV2();
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
    if (window.cortexDashboard) {
        window.cortexDashboard.cleanup();
    }
});
</script>
{% endblock %}
